import Architect.Content


open Lean

namespace Architect

section ToLatex

/-!
Conversion from Lean nodes to LaTeX.
-/

abbrev Latex := String

/-!
We convert nodes to LaTeX.

The output provides the following macros:
- `\inputleannode{name}`: Inputs the theorem or definition with label `name`.
- `\inputleanmodule{Module}`: Inputs the entire module (containing nodes in it) with module name `Module`.
-/

variable {m} [Monad m] [MonadEnv m]

/-- Since the LaTeX previously lived in the outer blueprint but now in a macro, previous commands like `\url{https://example.com#tag}`
throw an error at `#`. We need to escape it here. We also replace `\verb` with `\Verb` which is friendlier to macros. -/
def preprocessLatex (s : String) : String :=
  -- First replace `\#` with `#` in case the user already escaped it.
  let s' := s.replace "\\#" "#" |>.replace "#" "\\#"
  let s'' := s'.replace "\\verb" "\\Verb"
  s''

def moduleToRelPath (module : Name) (ext : String) : System.FilePath :=
  modToFilePath "module" module ext

def libraryToRelPath (library : Name) (ext : String) : System.FilePath :=
  System.mkFilePath ["library", library.toString (escape := false)] |>.addExtension ext

/-- Merges and converts an array of `NodePart` to LaTeX. It is assumed that `part ∈ allParts`. -/
def NodePart.toLatex (part : NodePart) (allParts : Array NodePart := #[part])
    (title : Option String := none) (additionalContent : String := "") : m Latex := do
  let mut out := ""
  out := out ++ "\\begin{" ++ part.latexEnv ++ "}"
  if let some title := title then
    out := out ++ s!"[{preprocessLatex title}]"
  out := out ++ "\n"

  -- Take union of uses
  let uses := allParts.flatMap (·.uses)
  unless uses.isEmpty do
    out := out ++ "\\uses{" ++ ",".intercalate uses.toList ++ "}\n"

  out := out ++ additionalContent

  -- \leanok only if all parts are leanOk
  if allParts.all (·.leanOk) then
    out := out ++ "\\leanok\n"

  out := out ++ (preprocessLatex part.text).trim ++ "\n"

  out := out ++ "\\end{" ++ part.latexEnv ++ "}\n"
  return out

def NodeWithPos.toLatex (node : NodeWithPos) : m Latex := do
  -- In the output, we merge the Lean nodes corresponding to the same LaTeX label.
  let env ← getEnv
  let allLeanNames := getLeanNamesOfLatexLabel env node.latexLabel
  let allNodes := allLeanNames.filterMap fun name => blueprintExt.find? env name

  let mut addLatex := ""
  addLatex := addLatex ++ "\\label{" ++ node.latexLabel ++ "}\n"

  addLatex := addLatex ++ "\\lean{" ++ ",".intercalate (allLeanNames.map toString).toList ++ "}\n"
  if node.notReady then
    addLatex := addLatex ++ "\\notready\n"
  if let some d := node.discussion then
    addLatex := addLatex ++ "\\discussion{" ++ toString d ++ "}\n"
  if let some location := node.location then
    if [`Init, `Lean, `Std, `Batteries, `Mathlib].any fun pre => pre.isPrefixOf location.module then
      addLatex := addLatex ++ "\\mathlibok\n"

  -- position string as annotation
  let posStr := match node.file, node.location with
    | some file, some location => s!"{file}:{location.range.pos.line}.{location.range.pos.column}-{location.range.endPos.line}.{location.range.endPos.column}"
    | _, _ => ""
  addLatex := addLatex ++ s!"% at {posStr}\n"

  let statementLatex ← node.statement.toLatex (allNodes.map (·.statement)) node.title addLatex
  match node.proof with
  | none => return statementLatex
  | some proof =>
    let proofLatex ← proof.toLatex (allNodes.filterMap (·.proof))
    return statementLatex ++ proofLatex

def NodeWithPos.toLatexHeader (node : NodeWithPos) : m Latex := do
  let latex ← node.toLatex
  return "\\newleannode{" ++ node.latexLabel ++ "}{\n" ++ latex ++ "}"

def BlueprintContent.toLatex : BlueprintContent → m Latex
  | .node n => return "\\inputleannode{" ++ n.latexLabel ++ "}"
  | .modDoc _ => return ""

def latexPreamble : m Latex := do
  return "%%% THIS FILE IS AUTO-GENERATED BY LeanArchitect. %%%

%%% Macro definitions for \\inputleannode, \\inputleanmodule %%%

\\makeatletter

% \\newleannode{name}{latex} defines a new Lean node
\\providecommand{\\newleannode}[2]{%
  \\expandafter\\gdef\\csname leannode@#1\\endcsname{#2}}
% \\inputleannode{name} inputs a Lean node
\\providecommand{\\inputleannode}[1]{%
  \\csname leannode@#1\\endcsname}

% \\newleanmodule{module}{latex} defines a new Lean module
\\providecommand{\\newleanmodule}[2]{%
  \\expandafter\\gdef\\csname leanmodule@#1\\endcsname{#2}}
% \\inputleanmodule{module} inputs a Lean module
\\providecommand{\\inputleanmodule}[1]{%
  \\csname leanmodule@#1\\endcsname}

\\makeatother

%%% Start of main content %%%"

private def moduleToLatexHeaderAux (module : Name) (contents : Array BlueprintContent) : m Latex := do
  let nodeHeaders ← contents.filterMapM fun
    | .node n => some <$> n.toLatexHeader
    | _ => pure none
  let moduleLatex ← contents.mapM BlueprintContent.toLatex
  let preamble ← latexPreamble
  return preamble ++ "\n\n" ++ "\n\n".intercalate nodeHeaders.toList ++ "\n\n" ++
    "\\newleanmodule{" ++ module.toString ++ "}{" ++ "\n\n".intercalate moduleLatex.toList ++ "}"

/-- Convert imported module to LaTeX. -/
def moduleToLatexHeader (module : Name) : CoreM Latex := do
  let contents ← getBlueprintContents module
  moduleToLatexHeaderAux module contents

/-- Convert current module to LaTeX (for debugging). -/
def mainModuleToLatexHeader : CoreM Latex := do
  let contents ← getMainModuleBlueprintContents
  moduleToLatexHeaderAux (← getMainModule) contents

/-- Shows the blueprint LaTeX of the current module for debugging. -/
syntax (name := show_blueprint) "#show_blueprint" (ppSpace ident)? : command

open Elab Command in
@[command_elab show_blueprint] def elabShowBlueprint : CommandElab
  | `(command| #show_blueprint) => do
    let latex ← liftCoreM mainModuleToLatexHeader
    logInfo m!"Exported blueprint LaTeX of current module:\n\n{latex}"
  | `(command| #show_blueprint $mod:ident) => do
    let mod := mod.getId
    if (← getEnv).getModuleIdx? mod |>.isNone then
      throwError "Unknown module {mod}"
    let latex ← liftCoreM <| moduleToLatexHeader mod
    logInfo m!"Exported blueprint LaTeX of module {mod}:\n\n{latex}"
  | _ => throwUnsupportedSyntax

end ToLatex

section ToJson

private def rangeToJson (range : DeclarationRange) : Json :=
  json% {
    "pos": $(range.pos),
    "endPos": $(range.endPos)
  }

private def locationToJson (location : DeclarationLocation) : Json :=
  json% {
    "module": $(location.module),
    "range": $(rangeToJson location.range)
  }

def NodeWithPos.toJson (node : NodeWithPos) : Json :=
  json% {
    "name": $(node.name),
    "latexLabel": $(node.latexLabel),
    "statement": $(node.statement),
    "proof": $(node.proof),
    "notReady": $(node.notReady),
    "discussion": $(node.discussion),
    "title": $(node.title),
    "hasLean": $(node.hasLean),
    "file": $(node.file),
    "location": $(node.location.map locationToJson)
  }

def BlueprintContent.toJson : BlueprintContent → Json
  | .node n => json% {"type": "node", "data": $(n.toJson)}
  | .modDoc d => json% {"type": "moduleDoc", "data": $(d.doc)}

def moduleToJson (module : Name) : CoreM Json := do
  return Json.arr <|
    (← getBlueprintContents module).map BlueprintContent.toJson

def mainModuleToJson : CoreM Json := do
  return Json.arr <|
    (← getMainModuleBlueprintContents).map BlueprintContent.toJson

/-- Shows the blueprint JSON of the current module for debugging. -/
syntax (name := show_blueprint_json) "#show_blueprint_json" (ppSpace ident)? : command

open Elab Command in
@[command_elab show_blueprint_json] def elabShowBlueprintJson : CommandElab
  | `(command| #show_blueprint_json) => do
    let json ← liftCoreM mainModuleToJson
    logInfo m!"Exported blueprint JSON of current module:\n\n{json}"
  | `(command| #show_blueprint_json $mod:ident) => do
    let mod := mod.getId
    if (← getEnv).getModuleIdx? mod |>.isNone then
      throwError "Unknown module {mod}"
    let json ← liftCoreM <| moduleToJson mod
    logInfo m!"Exported blueprint JSON of module {mod}:\n\n{json}"
  | _ => throwUnsupportedSyntax

end ToJson

open IO

/-- Write the result `content` to the appropriate blueprint file with extension `ext` ("tex" or "json"). -/
def outputResultsWithExt (basePath : System.FilePath) (module : Name) (content : String) (ext : String) : IO Unit := do
  FS.createDirAll basePath
  let filePath := basePath / moduleToRelPath module ext
  if let some d := filePath.parent then
    FS.createDirAll d
  FS.writeFile filePath content

/-- Write `latex` to the appropriate blueprint tex file. -/
def outputLatexResults (basePath : System.FilePath) (module : Name) (latex : Latex) : IO Unit := do
  let content := latex
  outputResultsWithExt basePath module content "tex"

/-- Write `json` to the appropriate blueprint json file. -/
def outputJsonResults (basePath : System.FilePath) (module : Name) (json : Json) : IO Unit := do
  let content := json.pretty
  outputResultsWithExt basePath module content "json"

/-- Write to an appropriate index tex file that \inputs all modules in a library. -/
def outputLibraryLatex (basePath : System.FilePath) (library : Name) (modules : Array Name) : IO Unit := do
  FS.createDirAll basePath
  let latex : Latex := "\n\n".intercalate
    (modules.map fun mod => "\\input{" ++ (basePath / moduleToRelPath mod "tex").toString ++ "}").toList
  let filePath := basePath / libraryToRelPath library "tex"
  if let some d := filePath.parent then
    FS.createDirAll d
  FS.writeFile filePath latex

/-- Write to an appropriate index json file containing paths to json files of all modules in a library. -/
def outputLibraryJson (basePath : System.FilePath) (library : Name) (modules : Array Name) : IO Unit := do
  FS.createDirAll basePath
  let json : Json := Json.mkObj [("modules", toJson (modules.map fun mod => moduleToRelPath mod "json"))]
  let content := json.pretty
  let filePath := basePath / libraryToRelPath library "json"
  if let some d := filePath.parent then
    FS.createDirAll d
  FS.writeFile filePath content

end Architect
